---
title: "动态规划"
author: "Luca"
date: "2023-08-10"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

动态规划方法是对问题暴力解法的优化。对于一个可以使用动态规划解决的问题，首先考虑如何使用简单不加优化的方法进行求解，然后识别方法中被重复计算的子问题。

例如，[Leetcode.5.最长回文子串](https://leetcode.cn/submissions/detail/454289347/)

1. 使用简单方法求解  
直观的解法是使用两层循环，判断s[i:j]是否为回文子串。
    ```{python eval=FALSE}
    for i in range(len(s)):
      for j in range(i+1, len(s)+1):
        t = s[i:j]
        if t == t[::-1] and len(t) > mlen:
          mlen = len(t)
          mstr = t
    print(mstr)
    ```
2. 识别重复计算的子问题  
当计算`s[i-n:j+n]`是否是回文子串时，都会判断`s[i,j]`是否是回文子串，因此子问题定义为判断`s[i,j]`是否是回文子串，记为$f(i, j)$（注意，对于本道题，问题本身和子问题**形式一致**）

3. 考虑子问题如何求解
$$
f(i, j) =\left\{
\begin{align}
& True & i = j\\
& f(i+1, j-1)\ \&\&\ s[i] == s[j] & i < j
\end{align}\right.
$$
4. 设计求解顺序
    ```{r setup, echo=FALSE}
library(r2d3)
r2d3(script = "../js/table-square.js", height = 170)
    ```
5. 构造原问题的解  
如果知道了每一个$f(i,j)$的值，答案表示为$s[i, j]$, 其中 $\underset{i,j}{max} (j-i)$

## 树形动态规划
[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/) 

[P1352. 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

[2023.小红书/美团 节点染色](https://mp.weixin.qq.com/s/NVSAjmmL48_PtLIOKXVQqg) 树中每个节点有一个权值。初始每个节点都是白色，每次操作可以选择两个相邻的节点，如果它们都是白色且权值的乘积是完全平方数，就可以把这两个节点同时染红，问最多可以染红多少个节点？

动态规划是将问题拆解为子问题，而树的特点是一个父节点可以有多个子节点，正好表达一个问题可以拆解为多个子问题，因此，动态规划和树结合是非常自然的事情，求解顺序一般是自底向上（使用深度优先搜索）或者非递归做法（队列中保存出度为 0 的节点（例如，洛谷1352.没有上司的舞会））

如果是二叉树的动态规划，汇集左右节点的结果构成root的结果，如果是一般的树的话，多个节点，一般使用result[N][K]保存节点的结果，搭配邻接矩阵表示图的方法来使用。

## 子问题的拆解
拆解子问题的关键：

1. 子问题的求解应该包含更小的子问题
2. 问题不应该影响子问题的求解

[505. 迷宫 II](https://leetcode.cn/problems/the-maze-ii/?envType=study-plan-v2&envId=premium-algo-100)

把 S -> E 的最短路径，拆成S到子节点的路径长度+子节点到E的最短路径，即min(S -> M$_{1...n}$) + min(M$_{1...n}$ -> E)，现在求子节点到

```{r, echo=FALSE}
htmltools::includeHTML("../html/node.html")
```
在树中容易确定一个求解顺序，而在图中不容易确定求解顺序，所以并不适合在图中使用动态规划的解法。还有一点区别，动态规划不会对子问题的解进行更新，在求解最短路径中，发现了某个到某点的较短路径，则更新到某点的路径长度。

